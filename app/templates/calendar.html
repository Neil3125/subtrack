{% extends "base.html" %}

{% block extra_head %}
<!-- FullCalendar CSS -->
<link rel="stylesheet" href="/static/css/calendar.css">
<!-- FullCalendar JS (CDN for stability) -->
<script src='https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.js'></script>
{% endblock %}

{% block content %}
<div class="calendar-wrapper">
    <!-- Top Control Bar (Search, Total, Action) -->
    <div
        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; flex-wrap: wrap; gap: 12px;">
        <div style="display: flex; align-items: center; gap: 16px;">
            <!-- Month Total Badge -->
            <div id="viewTotalBadge"
                style="background: var(--color-bg-secondary); padding: 8px 16px; border-radius: 20px; font-size: 0.95rem; font-weight: 600; color: var(--text-secondary); border: 1px solid var(--grid-border); display: flex; align-items: center; gap: 8px;">
                <span>View Total:</span>
                <span id="viewTotalAmount" style="color: var(--text-primary); font-size: 1.1rem;">$0.00</span>
            </div>
        </div>

        <div style="display: flex; gap: 12px; align-items: center;">
            <!-- Custom Search (External to FC) -->
            <div class="search-wrapper" style="position: relative;">
                <span
                    style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); color: var(--text-secondary);">üîç</span>
                <input type="text" id="calendarSearchInput" placeholder="Filter events..."
                    style="padding: 8px 8px 8px 32px; border: 1px solid var(--border-color); border-radius: 8px; background: var(--color-bg); color: var(--text-primary); width: 200px;">
            </div>

            <button id="addSubscriptionBtn" class="btn btn-primary" onclick="openModal('subscriptionModal')">
                <span>+</span> Add New
            </button>
        </div>
    </div>

    <!-- The Calendar -->
    <div id='calendar'></div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        var calendarEl = document.getElementById('calendar');
        var allEvents = []; // Store raw events for filtering

        var calendar = new FullCalendar.Calendar(calendarEl, {
            themeSystem: 'standard',
            initialView: 'dayGridMonth',
            headerToolbar: {
                left: 'prev,next today',
                center: 'title',
                right: 'dayGridMonth,timeGridWeek,timeGridDay,listMonth'
            },
            navLinks: true, // can click day/week names to navigate views
            editable: true,
            dayMaxEvents: true, // allow "more" link when too many events
            height: '100%',

            // Event Data Fetching
            events: async function (fetchInfo, successCallback, failureCallback) {
                try {
                    // Fetch wider range to ensure recurrence calculation works? 
                    // Actually, let's fetch everything or range. 
                    // The backend supports range.
                    const response = await fetch(`/api/subscriptions?status=active&start_date=${fetchInfo.startStr}&end_date=${fetchInfo.endStr}`);
                    if (!response.ok) throw new Error('Network response was not ok');
                    const subs = await response.json();

                    // Transform Subscriptions to Events
                    // We need to expand recurrence logic here because the API might only return the *next* date.
                    // If the user wants to see "Next Month", but the API only returns "Jan 15", filtering for Feb might return nothing 
                    // unless we simulate the recurrence.

                    // SIMPLIFIED APPROACH: We map what the API gives us. 
                    // If the user needs to see future recurrences not yet in DB, we would use rrule. 
                    // For now, let's map the provided "next_renewal_date".

                    // Note: If the user navigates far into future, API might return empty if no "next_renewal_date" falls there.
                    // Ideally, backend handles projection. 
                    // Hack: We can client-side simulate for the view range if `billing_cycle` is present.

                    let events = [];
                    const viewStart = new Date(fetchInfo.start);
                    const viewEnd = new Date(fetchInfo.end);

                    subs.forEach(sub => {
                        // Base event
                        let evtDate = new Date(sub.next_renewal_date);

                        // If date is within view, add it
                        if (evtDate >= viewStart && evtDate < viewEnd) {
                            events.push(createEventObj(sub, evtDate));
                        }

                        // RECURRENCE EXPANSION (Simple Client-Side)
                        // Allow projecting forward up to viewEnd
                        // Only do this if we want to confirm future months work even if DB isn't updated.
                        let nextDate = new Date(evtDate);
                        let safety = 0;
                        while (nextDate < viewEnd && safety < 12) { // limit 12 recurrences
                            // Calculate next
                            if (sub.billing_cycle === 'monthly') nextDate.setMonth(nextDate.getMonth() + 1);
                            else if (sub.billing_cycle === 'weekly') nextDate.setDate(nextDate.getDate() + 7);
                            else if (sub.billing_cycle === 'quarterly') nextDate.setMonth(nextDate.getMonth() + 3);
                            else if (sub.billing_cycle === 'yearly') nextDate.setFullYear(nextDate.getFullYear() + 1);
                            else break; // unknown cycle

                            if (nextDate >= viewStart && nextDate < viewEnd) {
                                events.push(createEventObj(sub, nextDate, true)); // isProjected=true
                            }
                            safety++;
                        }
                    });

                    allEvents = events; // Cache for local filtering
                    successCallback(events);
                } catch (error) {
                    console.error(error);
                    failureCallback(error);
                }
            },

            // Rendering Hooks
            eventDidMount: function (info) {
                // Apply tooltip?
                info.el.title = `${info.event.title} - ${info.event.extendedProps.currency} ${info.event.extendedProps.costDisplay}`;
            },

            datesSet: function (info) {
                calculateTotal(calendar.getEvents()); // Calc total for CURRENT view events
            },

            // Interactions
            eventClick: function (info) {
                // Open Edit Modal
                info.jsEvent.preventDefault(); // don't visit URL
                const subId = info.event.id.replace('proj-', ''); // remove projection prefix

                if (typeof openModal === 'function') {
                    // Trigger Edit Mode (reuse existing logic from global or create new)
                    // Passing ID to subscription modal
                    openModal('subscriptionModal');
                    // We'd ideally fetch and fill details here. 
                    // For now, prompt user it's experimental integration or fill basics.

                    // Fill basic fields from event props as fallback
                    const props = info.event.extendedProps;
                    setTimeout(() => {
                        const form = document.getElementById('subscription-form');
                        if (form) {
                            form.querySelector('[name="vendor_name"]').value = info.event.title;
                            form.querySelector('[name="cost"]').value = props.costDisplay;
                            // Add hidden ID support if needed
                        }
                    }, 100);
                }
            },

            dateClick: function (info) {
                // Open Add Modal pre-filled
                if (typeof openModal === 'function') {
                    openModal('subscriptionModal');
                    setTimeout(() => {
                        const form = document.getElementById('subscription-form');
                        if (form) {
                            form.reset();
                            form.querySelector('[name="start_date"]').value = info.dateStr;
                        }
                    }, 100);
                }
            },

            eventDrop: function (info) {
                // Drag & Drop logic (Update backend)
                if (!confirm(`Move ${info.event.title} to ${info.event.start.toLocaleDateString()}?`)) {
                    info.revert();
                } else {
                    // Call API to update date (Not implemeneted explicitly yet, stubbing)
                    console.log("Updated date for", info.event.id);
                }
            }
        });

        calendar.render();

        // Helper: Create FC Event Object
        function createEventObj(sub, dateObj, isProjected = false) {
            const catId = sub.category_id || 0;
            return {
                id: isProjected ? `proj-${sub.id}-${dateObj.getTime()}` : `${sub.id}`,
                title: sub.vendor_name,
                start: dateObj.toISOString().split('T')[0], // YYYY-MM-DD
                allDay: true,
                classNames: [`event-pastel-${catId % 6}`],
                extendedProps: {
                    costDisplay: sub.cost,
                    currency: sub.currency,
                    isProjected: isProjected
                }
            };
        }

        // Search Filter
        document.getElementById('calendarSearchInput').addEventListener('input', function (e) {
            const term = e.target.value.toLowerCase();
            // FullCalendar doesn't have a direct "filter" method that hides events easily without removing them.
            // Strategy: Refetch events? Or just toggle visibility using CSS?
            // CSS is cleaner for instant feeling.

            const events = calendar.getEvents();
            events.forEach(evt => {
                const match = evt.title.toLowerCase().includes(term);
                if (match) {
                    evt.setProp('display', 'auto');
                } else {
                    evt.setProp('display', 'none');
                }
            });

            // Recalculate total based on VISIBLE events
            const visibleEvents = events.filter(e => e.title.toLowerCase().includes(term));
            calculateTotal(visibleEvents);
        });

        function calculateTotal(eventsList) {
            // eventsList is array of FC Event Objects
            // We want total of visible events in current view

            // Note: calendar.getEvents() returns ALL events in memory/cache. 
            // We need only those in relevant range? 
            // Actually, getEvents() usually returns all.
            // Let's filter by current view active range.
            const view = calendar.view;
            if (!view) return;

            let total = 0;
            const currency = eventsList.length > 0 ? eventsList[0].extendedProps.currency : '$';

            eventsList.forEach(evt => {
                // Check if in view range
                if (evt.start >= view.activeStart && evt.start < view.activeEnd) {
                    // Check if not hidden by search
                    if (evt.display !== 'none') {
                        total += parseFloat(evt.extendedProps.costDisplay) || 0;
                    }
                }
            });

            const badge = document.getElementById('viewTotalAmount');
            badge.textContent = `${currency} ${total.toFixed(2)}`;
        }
    });
</script>
{% endblock %}